# To Do List
(git init para inicializar repo)

npm init -y
    Para crear: package.json
    Dentro de "scripts":
        "start": "node index.js",
        "dev": "nodemon index.js"

npm  i express
    requerir en index.js
    crear instancia de express (app)
    a√±adir el listener a app a trav√©s de una funci√≥n


npm i dotenv
    requerir dotenv .config()
    gestionar .env .env.example

crear .gitignore
    a√±adir .env & node_modules

-------------------

npm i mysql2
npm i sequelize


-------------------

db-index.js
    Requerir sequelize 
    Crear instancia de sequelize y en sus variables a√±adir (ver documtacion) datos de DB metidos en .env
    Exportar instancia (ojo con el formato de exportaci√≥n si es {destructuring} o no!)

index.js
    Requerir instancia sequelize
    Crear m√©todo para conectar BD a trav√©s de instancia sequelize y su metodo authenticate()
    A trav√©s de la instancia de express, se debe poner a la esucha la bd mediante el m√©todo listen()

Ahora toca MODEL
Si existen usuarios, se deber√≠a empezar por user:

models-user.model.js
    Requerir instancia sequelize
    Requerir DataTypes de sequelize
    Definir el modelo de User, utilizando sequelize.define
    Exportar User

index.js
    funci√≥n de sync() de sequelize

routes-index.js
    Requerir router de express
    Definimos las rutas que vamos a tener
    Exportar router

index.js 
    importar router
    app.use('/api', router) dentro de la funci√≥n listen

routes-auth.router
    importar router
    router.get

routes-index.js
    requerir router de express.Router()
    Requerir la ruta de auth y usarla a trav√©s de router propio del index con .use indicamos la ruta y el enrutador de auth

controllers-auth.controller.js
    Gestionamos funcion en primera instancia signup (e.g.)
    Exportamos funci√≥n  con destructuring {}

routes-auth.router.js
    Requerimos router de express.Router()
    Requerimos la funci√≥n de signup que est√° en el controlador de auth (que generaremos m√°s adelante)
    Gestionamos nuestra primera ruta:
        router.get('ruta!', funci√≥n signup)
    Exportamos el router


controllers-auth.controller.js
    Importamos el modelo correspondiente (user)
    Comenzamos a desarrollar la funcion de signup
    ** antes de seguir!**
        index.js
            a√±adimos en la funci√≥n listener la funcion json de express para poder devolver el .json dentro del controlador
        routes-auth.router.js
            ten en cuenta que en este archivo el router est√° como .get, pero como en la funci√≥n signup usaremos user.create, debemos cambiar a post porque le vamos a pasar info a trav√©s del body en el postman, y eso on se puede hacer con un .get. As√≠ que esto hay q tenerlo en cuenta. o lo cambias ahora o acu√©rdate luego ü´°0
            
    **
    como vamos a encriptar la contrase√±a:

    npm i bcrypt
    Requerimos bcrypt

    npm i jsonwebtoken
    Requerimos jwt
    
    Encriptamos el password usando el bcrypt.hash (ver documentaci√≥n)

    Usar el jwt.sign (ver documentaci√≥n) lo cual es el token, as√≠ que lo metemos dentro de la variable que llamaremos token


routes-auth.router.js
    repetimos proceso, estaba vez con la funcion login, realizando nuestra ruta para ello y enlanzando dicha funci√≥n que se encuentra en el controlador

controllers-auth.controller.js
    generamos funcion login donde hay que comprobar que el email coincide body con BD y lo mismo para la hashed contrase√±a body con BD

Siguiente modelo task
y crear las relaciones entre user-task en db-relationships.js